---
name: CLA Template

on:
  workflow_call:

jobs:
  checker:
    runs-on: ubuntu-latest

    steps:
      - name: Determine contributors and CLA status
        id: cla_check
        uses: actions/github-script@v8
        env:
          CLA_API_URL: ${{ secrets.CLA_API_URL }}
          CLA_API_TOKEN: ${{ secrets.CLA_API_TOKEN }}
          CLA_ORG_TOKEN: ${{ secrets.RPAT }}
          CLA_EFFECTIVE_DATE: ${{ secrets.CLA_EFFECTIVE_DATE }}
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            if (context.eventName === "merge_group" || context.payload.merge_group) {
              core.info("Merge group event detected; skipping CLA checks.");
              core.setOutput('author', 'merge_group');
              core.setOutput('is_internal', 'yes');
              core.setOutput('org_member', 'yes');
              core.setOutput('checked_contributors', JSON.stringify([]));
              core.setOutput('cla_statuses', JSON.stringify([]));
              core.setOutput('missing_cla', JSON.stringify([]));
              core.setOutput('team_names', JSON.stringify([]));
              core.setOutput('team_members', JSON.stringify({}));
              core.setOutput('org_used', process.env.CLA_ORG || context.repo.owner);
              return;
            }
            const pr = context.payload.pull_request;
            const author = pr.user.login;
            const claApiUrl = process.env.CLA_API_URL;
            const claToken = process.env.CLA_API_TOKEN;
            const org = process.env.CLA_ORG || context.repo.owner;
            const orgToken = process.env.CLA_ORG_TOKEN;
            if (!process.env.CLA_EFFECTIVE_DATE) {
              core.setOutput('skip_cla_comment', 'yes');
              core.setOutput('missing_cla', JSON.stringify([]));
              core.setOutput('checked_contributors', JSON.stringify([]));
              core.setOutput('cla_statuses', JSON.stringify([]));
              core.setFailed("CLA_EFFECTIVE_DATE is required but was not set.");
              return;
            }
            const effectiveDateRaw = process.env.CLA_EFFECTIVE_DATE;
            const effectiveDate = effectiveDateRaw ? new Date(effectiveDateRaw) : null;
            if (effectiveDateRaw && (!effectiveDate || Number.isNaN(effectiveDate.getTime()))) {
              core.setOutput('skip_cla_comment', 'yes');
              core.setOutput('missing_cla', JSON.stringify([]));
              core.setOutput('checked_contributors', JSON.stringify([]));
              core.setOutput('cla_statuses', JSON.stringify([]));
              core.setFailed(`Invalid CLA_EFFECTIVE_DATE: "${effectiveDateRaw}". Use ISO 8601 like "2026-01-01T00:00:00Z".`);
              return;
            }
            const orgGithub = orgToken ? new github.constructor({ auth: orgToken }) : github;
            const prNumber = pr.number;
            core.info(`Using org context: ${org}${orgToken ? " (token from CLA_ORG_TOKEN)" : " (default github-token)"}`);
            if (effectiveDate) {
              core.info(`CLA effective date set; checking commits on/after ${effectiveDate.toISOString()}`);
            }
            const teamNames = ["Caltech Employees", "MIT Employees", "JPL Employees"];
            const teamMembers = {};
            const ignoredUsers = new Set([
              "web-flow",
              "github-actions[bot]",
              "dependabot[bot]",
            ]);
            if (ignoredUsers.has(author) || author.endsWith("[bot]")) {
              core.info(`Skipping CLA check for system user: ${author}`);
              return;
            }
            const fetchTeamMembers = async (teamSlug, teamName) => {
              try {
                const members = [];
                const iterator = orgGithub.paginate.iterator(
                  orgGithub.rest.teams.listMembersInOrg,
                  { org, team_slug: teamSlug, per_page: 100 }
                );
                for await (const { data } of iterator) {
                  for (const member of data) {
                    members.push(member.login);
                  }
                }
                return members;
              } catch (error) {
                const message = error?.response?.data?.message || error.message;
                core.warning(`Failed to list members for ${teamName}: status ${error.status}, message: ${message}`);
                return [];
              }
            };

            const orgMembershipStatus = async (username) => {
              try {
                const res = await orgGithub.rest.orgs.checkMembershipForUser({
                  org,
                  username,
                });
                core.info(`Org membership check for ${username}: status ${res.status}`);
                return true;
              } catch (error) {
                const message = error?.response?.data?.message || error.message;
                core.info(`Org membership check failed for ${username}: status ${error.status}, message: ${message}`);
                return false;
              }
            };

            const isMemberOfAllowedTeams = async (username) => {
              for (const teamName of teamNames) {
                const teamSlug = teamName.trim().toLowerCase().replace(/\s+/g, "-");
                core.info(`Checking team membership for ${username} in "${teamName}" (slug: ${teamSlug})`);
                if (!teamMembers[teamName]) {
                  teamMembers[teamName] = await fetchTeamMembers(teamSlug, teamName);
                }
                if (teamMembers[teamName].includes(username)) {
                  core.info(`User ${username} found in fetched member list for ${teamName}`);
                  return true;
                }
                try {
                  const res = await orgGithub.rest.teams.getMembershipForUserInOrg({
                    org,
                    team_slug: teamSlug,
                    username,
                  });
                  core.info(`Team lookup response for ${teamName}: status ${res.status}, membership state ${res?.data?.state}`);
                  if (res?.data?.state === "active") {
                    return true;
                  }
                  core.info(`User ${username} exists but is not active in ${teamName}`);
                } catch (error) {
                  const message = error?.response?.data?.message || error.message;
                  if (error.status === 404) {
                    core.info(`User ${username} is not a member of ${teamName} (404)`);
                  } else {
                    core.warning(`Team lookup failed for ${teamName}: status ${error.status}, message: ${message}`);
                  }
                }
              }
              return false;
            };

            const addUser = (set, username, source) => {
              if (!username) {
                return;
              }
              if (ignoredUsers.has(username) || username.endsWith("[bot]")) {
                core.info(`Skipping ignored/bot user ${username} from ${source}`);
                return;
              }
              set.add(username);
            };

            const collectCommitters = async () => {
              const committers = new Set();
              let authorHasRecentCommit = false;
              const iterator = github.paginate.iterator(
                github.rest.pulls.listCommits,
                { owner: context.repo.owner, repo: context.repo.repo, pull_number: prNumber, per_page: 100 }
              );
              for await (const { data } of iterator) {
                for (const commit of data) {
                  const commitDate = commit.commit?.author?.date || commit.commit?.committer?.date;
                  const isWithinDate = !effectiveDate || (commitDate && new Date(commitDate) >= effectiveDate);
                  if (!isWithinDate) {
                    core.info(`Skipping commit ${commit.sha} because it was authored before the CLA effective date threshold: ${commitDate}`);
                    continue;
                  }
                  if (commit.author?.login === author || commit.committer?.login === author) {
                    authorHasRecentCommit = true;
                  }
                  addUser(committers, commit.author?.login, "commit.author");
                  addUser(committers, commit.committer?.login, "commit.committer");
                }
              }
              if (!effectiveDate || authorHasRecentCommit) {
                addUser(committers, author, "PR author");
              }
              return Array.from(committers);
            };

            const fetchClaStatus = async (user) => {
              const url = new URL(claApiUrl);
              url.searchParams.append("github_username", user);
              const res = await fetch(url.toString(), {
                headers: {
                  "X-CLA-Token": claToken
                }
              });
              if (!res.ok) {
                throw new Error(`CLA API error for ${user}: ${res.status} ${res.statusText}`);
              }
              const data = await res.json();
              core.info(`CLA status for ${user}: ${data.has_cla ? "signed" : "missing"}`);
              return data.has_cla;
            };

            const uniqueContributors = await collectCommitters();
            const missingCLA = [];
            const claStatuses = [];

            core.info(`Committers found: ${uniqueContributors.join(", ") || "none"}`);

            for (const user of uniqueContributors) {
              const isOrgMember = await orgMembershipStatus(user);
              const isInternal = await isMemberOfAllowedTeams(user);
              let hasCLA = false;

              if (isInternal) {
                hasCLA = true;
                core.info(`User ${user} is internal; CLA not required`);
              } else {
                try {
                  hasCLA = await fetchClaStatus(user);
                } catch (error) {
                  core.setFailed(error.message);
                  return;
                }
              }

              if (!isInternal && !hasCLA) {
                missingCLA.push(user);
              }

              claStatuses.push({
                user,
                is_internal: isInternal,
                is_org_member: isOrgMember,
                has_cla: hasCLA
              });
            }

            core.info(`Checked contributors: ${uniqueContributors.join(", ") || "none"}`);
            core.info(`Missing CLA: ${missingCLA.join(", ") || "none"}`);
            core.setOutput('team_names', JSON.stringify(teamNames));
            core.setOutput('team_members', JSON.stringify(teamMembers));
            core.setOutput('org_used', org);

            core.setOutput('author', author);
            core.setOutput('checked_contributors', JSON.stringify(uniqueContributors));
            core.setOutput('cla_statuses', JSON.stringify(claStatuses));
            core.setOutput('missing_cla', JSON.stringify(missingCLA));
            core.setOutput('skip_cla_comment', 'no');



            if (missingCLA.length > 0) {
              core.setFailed('Missing CLA for some contributors');
            }

      - name: Comment on PR if missing CLA
        if: failure() && steps.cla_check.outputs.missing_cla != '[]' && steps.cla_check.outputs.skip_cla_comment != 'yes'
        uses: actions/github-script@v8
        env:
          MISSING_CLA: ${{ steps.cla_check.outputs.missing_cla }}
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const missingCLA = JSON.parse(process.env.MISSING_CLA || '[]');
            const prNumber = context.payload.pull_request.number;
            const claUrl = 'https://ecodesign.clima.caltech.edu/cla/';
            const lines = [];
            lines.push('⚠️ **Contributor License Agreement required**');
            lines.push('');
            lines.push('The following contributor(s) must sign the CLA before this PR can be merged:');
            lines.push('');
            for (const user of missingCLA) {
              lines.push(`- @${user}`);
            }
            lines.push('');
            lines.push(`Please visit ${claUrl} to review and sign the CLA.`);
            lines.push('');
            lines.push('**How to sign:** Authenticate with GitHub then click the "I agree" button.');
            lines.push('');
            lines.push('_Once completed, re-run the checks on this PR._');

            const body = lines.join('\n');

            await github.rest.pulls.createReview({
              ...context.repo,
              pull_number: prNumber,
              event: 'COMMENT',
              body
            });

      - name: Workflow progress summary
        if: always()
        env:
          CLA_EFFECTIVE_DATE: ${{ secrets.CLA_EFFECTIVE_DATE }}
        run: |
          {
            echo "## CLA workflow progress"
            echo "- Author: ${{ steps.cla_check.outputs.author }}"
            echo "- Org used: ${{ steps.cla_check.outputs.org_used }}"
            echo "- Checked contributors: ${{ steps.cla_check.outputs.checked_contributors }}"
            echo "- Missing CLA: ${{ steps.cla_check.outputs.missing_cla }}"
            echo "- Allowed teams: ${{ steps.cla_check.outputs.team_names }}"
            if [ -z "$CLA_EFFECTIVE_DATE" ]; then
              echo "- Note: CLA_EFFECTIVE_DATE secret is missing"
            fi
            echo "- Outcome: ${{ job.status }}"
          } >> "$GITHUB_STEP_SUMMARY"
